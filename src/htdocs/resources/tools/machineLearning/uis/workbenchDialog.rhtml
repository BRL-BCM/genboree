<%# RENDER HTML%>
<%
  require 'brl/genboree/genboreeUtil'
  require 'brl/genboree/rest/apiCaller'
  require 'brl/genboree/rest/helpers/databaseApiUriHelper'
  require 'brl/genboree/rest/helpers/fileApiUriHelper'
  require "brl/db/dbrc"
  require 'uri'
  require 'json'
%>
<form id="wbDialogForm" name="wbDialogForm" action="wbDefault" style="width: 520px; height: 420px;" onsubmit="return submitToolJob(this);" method="POST" class="wbDialog wbForm" >

  <%# Tool Title %>
  <%= renderStaticFrag(@toolIdStr, :wbToolTitle) %>
  <%# Overview text %>
  <%= renderStaticFrag(@toolIdStr, :wbToolOverview,
      { :toolOverview =>
        "
          This tool will run a machine learning pipeline on the OTU table generated by a <span class='wbHelpMono'>QIIME</span> pipeline. Currently, two random forest algorithms are run, each provided by an R package:
          <ul>
            <li>Random Forest</li>
            <li>Boruta</li>
          </ul>
          <br>
          The input OTU table from your previous Qiime job will be filtered and normalized. A list of significant OTUs for            differentiating sample sets will be generated as output.
          <br>&nbsp;<br>
          <div style='width:100%; text-align:center; font-size: 80%;'><i>Additional details about the ouput files are provided in the </i>Addendum<i> at the bottom of the Help dialog.</i></div>
          "
      })
  %>

  <%# Input data summary %>
  <%= renderFrag(@toolIdStr, :wbDialogSection,
      {
        :sectionTitle => "Input Files Directory:",
        :sectionHtml => renderFrag(@toolIdStr, :wbFileDirSummary, { :fileList => @inputs } )
      })
  %>

 <%# Output database summary %>
  <%=
      if(@outputs.size == 1)
        renderFrag(@toolIdStr, :wbDialogSection,
        {
          :sectionTitle => "Output Database:",
          :sectionHtml => renderFrag(@toolIdStr, :wbDatabaseListSummary, { :databaseList => @outputs } )
        })
      else
        renderFrag(@toolIdStr, :wbDialogSection,
        {
          :sectionTitle => "Output Database/Project:",
          :sectionHtml =>
            renderFrag(@toolIdStr, :wbProjectOrDatabaseListSummary, { :projectOrDatabaseList => @outputs, :label => "Database/Projects Of Interest" } )
        })
      end

  %>

  <%# Tool-specific UI widgets user provides/reviews %>
  <%=
    # Get the list of samples to display
    # Check if input folder is part of the "QIIME" tree
    inputFolderPath = @inputs[0]
    if(inputFolderPath !~ /\/QIIME\//)
      wue = BRL::Genboree::Tools::WorkbenchUIError.new(:'Precondition Failed', "MISSING_DIRECTORY: Input folder/directory for Machine Learning needs to be part of the 'QIIME' folder ")
      raise wue
    end
    fileUri = @inputs[0].gsub("/files", "/file")
    fileUri = fileUri.chomp("?")
    fileUri << "/sample.metadata/data?"
    uri = URI.parse(fileUri)
    apiDbrc = BRL::Genboree::GenboreeUtil.getSuperuserDbrc(@genbConf, @genbConf.dbrcFile)
    apiCaller = ApiCaller.new(uri.host, uri.path, apiDbrc.user, apiDbrc.password)

    # Do internal request if enabled (in this case, if we've been given a Rack env hash to work from)
    retVal = ""
    apiCaller.initInternalRequest(@rackEnv, @genbConf.machineNameAlias) if(@rackEnv)
    resp = apiCaller.get()
    if(apiCaller.succeeded?)
      retVal = apiCaller.respBody
    else
      $stderr.puts "ERROR: apiCaller to get features failed. resp body:\n#{apiCaller.respBody.inspect}"
    end
    buffIO = StringIO.new(retVal)
    featureLine = buffIO.readline
    featureLine.gsub!("#", "")
    features = featureLine.chomp.split(/\t/)
    featureIndexHash = {}
    features.size.times { |featureIndex|
      featureIndexHash[features[featureIndex]] = featureIndex
    }
    features.uniq!


    # Check that there are at least 3 unique 'sampleName' records
    sampleNames = []
    buffIO.each_line { |line|
      columns = line.split(/\t/)
      sampleNames.push(columns[featureIndexHash['sampleName']])
    }
    if(sampleNames.uniq.size < 3)
      wue = BRL::Genboree::Tools::WorkbenchUIError.new(:'Precondition Failed', "MISSING_VALUES: There MUST be at least 3 unique samples in the sample.metadata file to run Machine Learning")
      raise wue
    end

    # Get kill list
    buffIO = StringIO.new(retVal)
    opsList = []
    killList = @genbConf.microbiomeKillList
    if(!features.nil? and !features.empty?)
      tempList = features - killList
      featureHash = {}
      tempList.each { |feature|
        featureHash[feature] = {}
      }
      # Now pick out only those features that have at least 2 unique records
      buffIO.readline
      buffIO.each_line { |line|
        records = line.chomp.split(/\t/)
        featureHash.each_key { |feature|
          featureHash[feature][records[featureIndexHash[feature]]] = nil
        }
      }
      featureHash.each_key { |feature|
        $stderr.puts "featureHash[feature].keys: #{featureHash[feature].keys.inspect}"
        opsList.push(feature) if(featureHash[feature].keys.size > 1)
      }
      if(opsList.empty?)
        wue = BRL::Genboree::Tools::WorkbenchUIError.new(:'Precondition Failed', "MISSING_VALUES: There MUST be at least 2 unique values for at least one feature to run Machine Learning")
        raise wue
      end
    end
    renderFrag(@toolIdStr, :wbToolSettingsUI,
    {
      :sectionTitle => "Settings",
      :widgets =>
      [
        { :id => 'studyName', :label => 'Study Name', :type => :text , :style => "width: 320px", :value => "", :title => "The output folder for the Machine Learning results" },
        { :id => 'jobName', :label => 'Job Name', :type => :text ,  :style => "width: 320px", :value => "ML-Job-#{Time.now.strftime('%Y-%m-%d-%H:%M:%S')}", :title => "Give this job a unique name" },
        { :id => "featureList", :label =>'Feature List', :type => :selectWithToggle, :size => '7', :text => 'Select features you wish to include', :selectByDefault => :all, :multiSelect => true,
          :toggleAllButton => true, :title => "Metadata features provided by user. (Example: age, ethnic, etc)", :options => opsList, :width => 200}
      ]
    })

  %>
  <%= renderStaticFrag(@toolIdStr, :wbToolButtons,
      {
        :buttons => [ { :type => :submit }, { :type => :cancel} ]
      })
  %>
</form>
