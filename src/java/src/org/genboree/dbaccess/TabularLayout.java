package org.genboree.dbaccess;

import java.sql.ResultSet ;
import java.sql.Connection ;
import java.sql.Statement ;
import java.sql.SQLException ;
import java.util.Date ;
import java.util.Vector ;
import java.util.Calendar ;

/**
 * This class represents the saved tabular layouts generated by the Tabular
 * Layout and View Tool (java-bin/tabular.jsp).  These layouts were previously
 * saved to the disk for storage, but now are stored in a database table in the
 * user databases.
 * @author sgdavis@bioneos.com
 */
public class TabularLayout
{
  protected int id = -1 ;
  protected String name = "";
  protected int userId ;
  protected Date createDate ;
  protected Date lastModifiedTime ;
  protected String description = "";
  protected String columns = "";
  protected String sort = "";
  protected String groupMode = "";
  // Reserved for future use
  protected int flags ;

  // Should not be changed
  private String databaseName = null ;

  // Group Mode constants
  public static final int GROUP_NONE = 0 ;
  public static final int GROUP_TERSE = 1 ;
  public static final int GROUP_VERBOSE = 2 ;

  public int getId()
  {
    return id ;
  }
  public void setId(int id)
  {
    this.id = id ;
  }

  public String getName()
  { 
    return name ;
  }
  public void setName(String name)
  {
    this.name = name ;
  }

  public int getUserId()
  {
    return userId ;
  }
  public void setUserId(int userId)
  {
    this.userId = userId ;
  }

  public Date getCreateDate()
  {
    return createDate ;
  }
  public void setCreateDate(Date createDate)
  {
    this.createDate = createDate ;
  }

  public Date getLastModifiedTime()
  {
    return lastModifiedTime ;
  }
  public void setLastModifiedTime(Date modTime)
  {
    this.lastModifiedTime = modTime ;
  }

  public String getDescription()
  {
    return (description == null) ? "" : description ;
  }
  public void setDescription(String desc)
  {
    this.description = desc ;
  }

  public String getColumns()
  {
    return columns ;
  }
  public void setColumns(String cols)
  {
    this.columns = cols ;
  }

  public String getSort()
  {
    return sort ;
  }
  public void setSort(String sort)
  {
    this.sort = sort ;
  }

  public String getGroupMode()
  {
    return groupMode ;
  }
  public void setGroupMode(String mode)
  {
    if(mode == null) groupMode = "" ;
    else if(mode.equals("verbose") || mode.equals("terse")) groupMode = mode ;
    else groupMode = "" ;
  }
  public void setGroupMode(int mode)
  {
    if(mode == GROUP_NONE) groupMode = "" ;
    else if(mode == GROUP_TERSE) groupMode = "terse" ;
    else if(mode == GROUP_VERBOSE) groupMode = "verbose" ;
  }

  public int getFlags()
  {
    return flags ;
  }
  public void setFlags(int flags)
  {
    this.flags = flags ;
  }

  /**
   * Produce a JSON String representing the data stored in this Object.
   * @return
   *   A valid JSON Object as a String.
   */
  public String toJson()
  {
    return "{" + 
      "\"name\":\"" + getName().replaceAll("\"", "\\\\\"") + "\"," + 
      "\"description\":\"" + getDescription().replaceAll("\"", "\\\\\"") + "\"," + 
      "\"userId\":" + getUserId() + "," +
      "\"created\":\"" + getCreateDate() + "\"," + 
      "\"modified\":\"" + getLastModifiedTime() + "\"," + 
      "\"columns\":\"" + getColumns() + "\"," +
      "\"sort\":\"" + getSort() + "\"," + 
      "\"groupMode\":\"" + getGroupMode() + "\"" + 
      "}" ;
  }

  /**
   * Insert this {@link TabularLayout} into permanent storage in the user 
   * database.  Must supply a databaseName.
   * <br><br><b>NOTE:</b>Proper authentication checks
   * must be performed <b>before</b> calling this method.  This method does not
   * perform any access checking.  Only users with AUTHOR (w) and ADMINISTRATOR
   * (o) access on the database should be able to create new layouts.
   * @param db
   *   The {@link DBAgent} from which to grab a {@link Connection} to the user
   *   database.
   * @param dbName
   *   The database name for the user database.
   */
  public void insert(DBAgent db, String dbName)
    throws SQLException
  {
    if(dbName == null)
      throw new SQLException("TabularLayout.insert(): You must specify a name for the user database (not null)") ;
    databaseName = dbName ;
    Connection conn = db.getConnection(dbName) ;
    if(conn == null)
    {
      db.reportError(new Exception("Cannot get connection to: " + dbName), "TabularLayout.insert()") ;
      databaseName = null ;
    }

    // Translate groupMode String to int
    int group = 0 ; 
    if(groupMode.equals("terse")) group = GROUP_TERSE ;
    else if(groupMode.equals("verbose")) group = GROUP_VERBOSE ;

    Statement st = conn.createStatement() ;
    String query = "INSERT INTO tabularLayouts (name, userId, createDate, " + 
      "lastModDate, description, columns, sort, groupMode, flags) VALUES " +
      "('" + name.replaceAll("'", "\\\\'") + "', " + userId + ", CURDATE(), NOW(), '" +
      description.replaceAll("'", "\\\\'") + "', '" + columns.replaceAll("'", "\\\\'") + "', '" +
      sort.replaceAll("'", "\\\\'") + "', " + group + ", 0)" ;
    st.executeUpdate(query) ;

    // Now set our id
    ResultSet rs = st.executeQuery("SELECT LAST_INSERT_ID()") ;
    if(rs.next()) setId(rs.getInt(1)) ;

    // Clean up
    st.close() ;
  }

  /**
   * Update the database with the values currently stored in this 
   * {@link TabularLayout}.<br><br><b>NOTE:</b>Proper authentication checks
   * must be performed <b>before</b> calling this method.  This method does not
   * perform any access checking.  Only users with AUTHOR (w) and ADMINISTRATOR
   * (o) access on the database storing this layout should be allowed to 
   * perform an update.
   * @param db
   *   The {@link DBAgent} from which to grab a {@link Connection} to the user
   *   database.
   */
  public void update(DBAgent db)
    throws SQLException
  {
    if(databaseName == null || id == -1)
      throw new SQLException("TabularLayout.update(): Cannot update object that hasn't been properly inserted") ;
    Connection conn = db.getConnection(databaseName) ;
    if(conn == null)
      db.reportError(new Exception("Cannot get connection to: " + databaseName), "TabularLayout.update()") ;

    // Translate groupMode String to int
    int group = 0 ; 
    if(groupMode.equals("terse")) group = GROUP_TERSE ;
    else if(groupMode.equals("verbose")) group = GROUP_VERBOSE ;

    Statement st = conn.createStatement() ;
    String query = "UPDATE tabularLayouts SET name='" + name.replaceAll("'", "\\\\'") + "', " +
      "lastModDate=NOW(), groupMode=" + group + ", " +
      "description='" + description.replaceAll("'", "\\\\'") + "', " + 
      "columns='" + columns.replaceAll("'", "\\\\'") + "', " +
      "sort='" + sort.replaceAll("'", "\\\\'") + "' " +
      "WHERE id=" + id ;
    st.executeUpdate(query) ;

    // Clean up
    st.close() ;
  }

  /**
   * Delete this layout from its storage in the user database. 
   * <br><br><b>NOTE:</b>Proper authentication checks
   * must be performed <b>before</b> calling this method.  This method does not
   * perform any access checking.  Only users with ADMINISTRATOR (o) access on
   * the database storing this layout should be allowed to delete layouts.
   * @param db
   *   The {@link DBAgent} from which to grab a {@link Connection} to the user
   *   database.
   */
  public void delete(DBAgent db)
    throws SQLException
  {
    if(databaseName == null || id == -1)
      throw new SQLException("TabularLayout.delete(): Cannot delete object that hasn't been properly inserted") ;
    Connection conn = db.getConnection(databaseName) ;
    if(conn == null)
      db.reportError(new Exception("Cannot get connection to: " + databaseName), "TabularLayout.delete()") ;

    // Actually perform the delete
    Statement st = conn.createStatement() ;
    String query = "DELETE FROM tabularLayouts WHERE id=" + id ;
    st.executeUpdate(query) ;

    // Remove identifiers
    id = -1 ;
    databaseName = null ;

    // Clean up
    st.close() ;
  }

  /**
   * Static helper method to grab a single {@link TabularLayout} by its
   * id (user database specfic).  User database is specified by providing
   * the proper {@link Connection} object.
   * @param conn
   *   The {@link Connection} to fetch the layout from.
   * @param layoutId
   *   The id of the layout to fetch.
   */
  public static TabularLayout fetchById(Connection conn, int layoutId)
    throws SQLException
  {
    if(conn == null) return null ;

    String query = "SELECT id, name, userId, createDate, lastModDate, " +
      "description, columns, sort, groupMode, flags FROM tabularLayouts " + 
      "WHERE id = " + layoutId ;
    return fetchBySql(conn, query) ;
  }

  /**
   * Static helper method to grab a single {@link TabularLayout} by its
   * name (user database specfic).  User database is specified by providing
   * the proper {@link Connection} object.
   * @param conn
   *   The {@link Connection} to fetch the layout from.
   * @param layoutName
   *   The name of the layout to fetch.
   */
  public static TabularLayout fetchByName(Connection conn, String layoutName)
    throws SQLException
  {
    if(conn == null) return null ;

    String query = "SELECT id, name, userId, createDate, lastModDate, " +
      "description, columns, sort, groupMode, flags FROM tabularLayouts " + 
      "WHERE name = '" + layoutName.replaceAll("'", "\\\\'") + "'" ;
    return fetchBySql(conn, query) ;
  }

  /*
   * Private helper method to simplify fetchByName() and fetchById().
   * This should remain private because it is highly dependant on the code
   * in the other two methods (especially field order in the sql).
   */
  private static TabularLayout fetchBySql(Connection conn, String sql)
    throws SQLException
  {
    // Determine our database name to associate the objects with
    String dbName = conn.getMetaData().getURL() ;
    dbName = dbName.substring(dbName.lastIndexOf('/') + 1) ;

    // Grab all objects
    Statement st = conn.createStatement() ;
    ResultSet rs = st.executeQuery(sql) ;
    TabularLayout layout = null ;
    if(rs.next())
    {
      layout = new TabularLayout() ;
      layout.setId(rs.getInt(1)) ;
      layout.setName(rs.getString(2)) ;
      layout.setUserId(rs.getInt(3)) ;
      try
      {
        layout.setCreateDate(rs.getDate(4)) ;
      }
      catch (SQLException e)
      {
        // Date was formatted incorrectly
        System.err.println("TabularLayout.fetchBySql(): Create date incorrect in db: " + e) ;
        layout.setCreateDate(Calendar.getInstance().getTime()) ;
      }
      try
      {
        layout.setLastModifiedTime(rs.getTime(5)) ;
      }
      catch (SQLException e)
      {
        // Date was formatted incorrectly
        System.err.println("TabularLayout.fetchBySql(): Last modified date incorrect in db: " + e) ;
        layout.setLastModifiedTime(Calendar.getInstance().getTime()) ;
      }
      layout.setDescription(rs.getString(6)) ;
      layout.setColumns(rs.getString(7)) ;
      layout.setSort(rs.getString(8)) ;
      layout.setGroupMode(rs.getInt(9)) ;
      layout.databaseName = dbName ;
    }

    // Clean up
    st.close() ;
    return layout ;
  }

  /**
   * Static helper method to grab all of the {@link TabularLayout}s for a
   * user database.  User database is specified by providing the proper
   * {@link Connection} object.
   * @param conn
   *   The {@link Connection} to fetch the layouts from.
   */
  public static TabularLayout[] fetchAll(Connection conn)
    throws SQLException
  {
    if(conn == null) return null ;

    // Determine our database name to associate the objects with
    String dbName = conn.getMetaData().getURL() ;
    dbName = dbName.substring(dbName.lastIndexOf('/') + 1) ;

    // Grab all objects
    String query = "SELECT id, name, userId, createDate, lastModDate, description, " +
      "columns, sort, groupMode, flags FROM tabularLayouts ORDER BY name" ;
    Statement st = conn.createStatement() ;
    ResultSet rs = st.executeQuery(query) ;
    Vector<TabularLayout> results = new Vector<TabularLayout>() ;
    while(rs.next())
    {
      TabularLayout layout = new TabularLayout() ;
      layout.setId(rs.getInt(1)) ;
      layout.setName(rs.getString(2)) ;
      layout.setUserId(rs.getInt(3)) ;
      try
      {
        layout.setCreateDate(rs.getDate(4)) ;
      }
      catch (SQLException e)
      {
        // Date was formatted incorrectly
        System.err.println("TabularLayout.fetchAll(): Create date incorrect in db: " + e) ;
        layout.setCreateDate(Calendar.getInstance().getTime()) ;
      }
      try
      {
        layout.setLastModifiedTime(rs.getTime(5)) ;
      }
      catch (SQLException e)
      {
        // Date was formatted incorrectly
        System.err.println("TabularLayout.fetchAll(): Last modified date incorrect in db: " + e) ;
        layout.setLastModifiedTime(Calendar.getInstance().getTime()) ;
      }
      layout.setDescription(rs.getString(6)) ;
      layout.setColumns(rs.getString(7)) ;
      layout.setSort(rs.getString(8)) ;
      layout.setGroupMode(rs.getInt(9)) ;
      layout.databaseName = dbName ;
      results.add(layout) ;
    }

    // Clean up
    st.close() ;
    TabularLayout[] resultArray = new TabularLayout[results.size()] ;
    results.copyInto(resultArray) ;
    return resultArray ;
  }
}
