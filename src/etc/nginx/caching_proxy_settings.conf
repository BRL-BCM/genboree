 # Use HTTP 1.1 for greatest caching features. Probably doesn't matter.
 proxy_http_version 1.1 ;

 # Resolvers are not inherited. Usuaally we use upstream definitions (pre-resolved when nginx starts up)
 #   but this won't work if host is dynamic from query!
 resolver 8.8.8.8  8.8.8.4 ;
 
 # Indicate the key_zone to use for proxy-caching
 proxy_cache respCache ;
 
 # What responses are valid and for how long?
 proxy_cache_valid 200 304 10y;
 
 # Should proxy intercept and process error responses or pass directly to client?
 proxy_intercept_errors on ;
 
 # What's the key to use for caching (basically the URL minus $host, which is us anyway) (was $host$uri$is_args$args )
 proxy_cache_key $uri$is_args$args ;
 
 # Nginx will respect cache-control and related headers...turn that off (bioontology.org used to return 'private' for this field!)
 # Nginx as of 1.7.7 pays attention to Vary when caching...and the bad-practices of bioontology.org for Vary field cause no-HIT (not even storage)
 proxy_ignore_headers Cache-Control Set-Cookie Expires Vary X-Accel-Expires X-Accel-Buffering X-Accel-Limit-Rate X-Accel-Charset X-Accel-Redirect ;
 
 # Don't pass Set-Cookie through (shouldn't come up for bioontology.org)
 proxy_hide_header Set-Cookie ;
 
 # What methods to cache?
 proxy_cache_methods GET ;
 
 # When should we preferentially use a stale cache item when talking to upstream proxy
 #  fails or cache entry is already being updated by another thread?
 proxy_cache_use_stale error timeout invalid_header updating ;
 
 # Should if-modified-since and if-none-match headers be paid attention to for
 # revalidating expired cache items? (default off)
 proxy_cache_revalidate off ;

 # Pass the CACHED Date header, don't generate one anew.
 # - Esp. important because we examine this date header to see if we should
 #   force-update the cached record (i.e. if too old)
 proxy_pass_header Date ;

 # ------------------------------------------------------------------
 # Cache INSTRUCTION operations
 # ------------------------------------------------------------------
 # Under what conditions should the cache be BYPASSED (not consulted)
 # - Often some variables you set in location/if configs
 # - If any variable is non-empty and non-"0", cache is bypassed
 # - Easiest to do this via custom headers and the automatic variables nginx creates for you.
 #   . Simply set an HTTP header to "true" and it will trigger this rule.
 #   . e.g. for this case below:   X-GB-Bypass-Cache:true
 proxy_cache_bypass $http_x_gb_bypass_cache ;

 # Under what conditions should the cache NOT BE UPDATED with the response.
 # - Often some variables you set in location/if configs
 # - If any variable is non-empty and non-"0", cache is bypassed
 # - Easiest to do this via custom headers and the automatic variables nginx creates for you.
 #   . Simply set an HTTP header to "true" and it will trigger this rule.
 #   . e.g. for this case below:   X-GB-Dont-Cache:true
 proxy_no_cache $http_x_gb_dont_cache $dont_cache_head ;

 # Under what conditions should the cache entry be PURGED?
 # - Generally some variables you set in location/if configs
 # - If any variable is non-empty and non-"0", cache is bypassed
 # - Easiest to do this via custom headers and the automatic variables nginx creates for you.
 #   . Simply set an HTTP header to "true" and it will trigger this rule.
 #   . e.g. for this case below:   X-GB-Purge-Cache:true
 # - This will return 204 no content upon success
 proxy_cache_purge PURGE ;

 add_header X-GB-Cache-Status $upstream_cache_status;
