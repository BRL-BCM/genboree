require 'brl/genboree/tools/workbenchRulesHelper'
require 'brl/genboree/tools/workbenchFormHelper'
require 'brl/genboree/rest/helpers/databaseApiUriHelper'
require 'brl/genboree/rest/helpers/fileApiUriHelper'
require 'uri'
require 'brl/genboree/genboreeUtil'
require 'brl/genboree/rest/apiCaller'
require 'brl/genboree/helpers/sniffer'
include BRL::Genboree::REST

module BRL ; module Genboree ; module Tools
  class ProcessPipelineRunsRulesHelper < WorkbenchRulesHelper
    TOOL_ID = 'processPipelineRuns'
    
    def rulesSatisfied?(wbJobEntity, sectionsToSatisfy=[ :inputs, :outputs, :context, :settings ], toolIdStr=@toolIdStr)
      # Grab necessary variables for grabbing submitter's ERCC info (used for tool usage doc)
      exRNAInternalKBHost = @genbConf.exRNAInternalKBHost
      exRNAInternalKBGroup = @genbConf.exRNAInternalKBGroup
      exRNAInternalKBName = @genbConf.exRNAInternalKBName
      exRNAInternalKBPICodesColl = @genbConf.exRNAInternalKBPICodesColl
      submitterPropPath = "ERCC PI Code.Submitters.Submitter ID.Submitter Login"
      # Grab dbrc info for making API call to PI Codes collection
      user = @superuserApiDbrc.user
      pass = @superuserApiDbrc.password
      # Apply basic rules from the rules file (counts, basic types, other simple things)
      rulesSatisfied = super(wbJobEntity, sectionsToSatisfy, toolIdStr)
      # Save outputs in variable
      outputs = wbJobEntity.outputs
      # batchJob keeps track of whether this job was submitted via exceRptPipeline (batchJob=true) or whether the tool was launched as stand-alone (batchJob=false)
      batchJob = wbJobEntity.settings["isBatchJob"]
      # We only do the various checks below for the stand-alone tool. Since the inputs in the batch job case are regulated programmatically by exceRptPipeline, we don't need to check anything.
      unless(batchJob)
        errorMsgArr = []
        if(rulesSatisfied)
          inputsList = []
          invalidFiles = []
          invalidFolders = []
          # Grab inputs
          initialInputs = wbJobEntity.inputs
          # STEP 1: Check inputs and make sure that user has supplied valid inputs - if any inputs are invalid, let user know 
          # First, we check each input to see if it is a file or a folder
          initialInputs.each { |initialInputFile|
            # File
            if(initialInputFile =~ BRL::Genboree::REST::Helpers::FileApiUriHelper::NAME_EXTRACTOR_REGEXP)
              # If file is valid input, then add it to inputsList - otherwise, add it to invalidFiles to report later 
              if(initialInputFile =~ /_CORE_RESULTS_v(\d\.\d\.\d)(?:.tgz)/ or initialInputFile =~ /_results_v(\d\.\d\.\d)(?:.zip)/)
                inputsList << initialInputFile
              else
                invalidFiles << initialInputFile 
              end 
            elsif(initialInputFile =~ BRL::Genboree::REST::Helpers::FileEntityListApiUriHelper::NAME_EXTRACTOR_REGEXP)
              # Entity List
              fileList = @fileApiHelper.expandFileContainers(initialInputFile, @userId)
              # For each file in entity list, if file is valid input, then add it to inputsList - otherwise, add it to invalidFiles to report later
              fileList.each { |file|
                if(file =~ /_CORE_RESULTS_v(\d\.\d\.\d)(?:.tgz)/ or file =~ /_results_v(\d\.\d\.\d)(?:.zip)/)
                  inputsList << file
                else
                  invalidFiles << file 
                end
              }
            else
              # Folders
              # Grab entire file list of current folder using expandFileContainers
              fileList = @fileApiHelper.expandFileContainers(initialInputFile, @userId)
              # validFolder will keep track of whether current folder contains any valid files 
              validFolder = false 
              # Latest version of CORE_RESULTS archive has the .stats file inside the archive -
              # this is generated by the pipeline makefile
              unless(fileList.grep(/\/CORE_RESULTS\/.*\.stats$/).empty?)
                # See whether file list contains any CORE_RESULTS archives - if so, add them to inputsList 
                coreResultsFile = fileList.grep(/_CORE_RESULTS_v(\d\.\d\.\d)(?:.tgz)/)
                coreResultsFile.each { |resFile| 
                  inputsList << resFile
                  validFolder = true 
                }
              # Handle those cases from a slightly older version of the pipeline - CORE_RESULTS does not have .stats
              # file, so we use the original large results.zip archive
              else
                resultsFile = fileList.grep(/_results_v(\d\.\d\.\d)(?:.zip)/)
                resultsFile.each { |resFile|
                  inputsList << resFile
                  validFolder = true 
                }
              end
              # Folder is invalid unless we found at least one valid archive above 
              invalidFolders << initialInputFile unless(validFolder)
            end
          }
          # If we found any invalid files or folders, then we should raise an error because all of our inputs were not valid
          unless(invalidFiles.empty? and invalidFolders.empty?)
            rulesSatisfied = false 
            error = "Your input file list contained some INVALID INPUTS for the exceRpt small RNA-seq post-processing tool.\nYour inputs should be archive files (_CORE_RESULTS_v or _results_v) generated by the exceRpt pipeline and/or folders containing valid archive files."
            errorMsgArr.push(error)
            errorMsgArr.push("List of invalid files: #{invalidFiles.join(", ")}") unless(invalidFiles.empty?)
            errorMsgArr.push("List of invalid folders: #{invalidFolders.join(", ")}") unless(invalidFolders.empty?)
          end
          # If error message array is empty, then we proceed to STEP 2: checking version numbers between valid inputs to make sure that they all match 
          if(errorMsgArr.empty?)
            # versions will hold each file's version
            versions = []
            # Traverse all inputs gathered above 
            inputsList.each { |currentInput|
              # Find the version of the current file 
              currentVersion = currentInput.match((/v(\d\.\d\.\d)(?:.zip|.tgz)/))[1]
              versions.push(currentVersion)
            }
            # Unless the number of unique values in the versions array is 1 (ALL VERSIONS ARE THE SAME), then we need to raise an error
            unless(versions.uniq.length == 1)
              rulesSatisfied = false
              errorMsgArr.push("NON_MATCHING_VERSION_NUMBERS: Input files have differing version numbers - version numbers must match exactly in order to post-process exceRpt pipeline results.")
              errorMsgArr.push("List of versions found: #{versions.uniq.join(", ")}")
            else
              genNumber = versions[0][0].chr
              if(genNumber != "3" and genNumber != "4")
                rulesSatisfied = false
                errorMsgArr.push("OUTDATED_VERSION: Your input files are from 2nd gen exceRpt (or earlier!) and are no longer supported on Genboree. Please re-run your samples through the current version of exceRpt.")
              else
                # Save version for later
                wbJobEntity.settings['inputsVersion'] = versions[0]
              end
            end
          end
          # If we didn't get any errors above, we'll proceed to STEP 3: Sniffing our files to make sure they're .tgz or .zip.
          # Note that we only complete this step in the RulesHelper if the number of inputs is <= 20 - if it's greater than 20, then we'll do the check in the actual wrapper 
          if(errorMsgArr.empty?)
            if(inputsList.size <= 20)
              # We need to check each input to make sure that it's a .zip or .gz file
              inputsList.each { |input|
                # Grab the URI for that input
                fileUriObj = URI.parse(input)
                # Create apiCaller for checking format of file
                apiCaller = ApiCaller.new(fileUriObj.host, "#{fileUriObj.path}/format?", @hostAuthMap)
                apiCaller.initInternalRequest(@rackEnv, genbConf.machineNameAlias) if(@rackEnv)
                # Grab file format
                apiCaller.get()
                type = apiCaller.parseRespBody["data"]["text"]
                # If the type is NOT zip or gz (tgz), then we reject the file because we are only accepting zip or gz (tgz) archive files at the moment
                # TODO: Check for .tar.gz instead of just .gz?
                if(type != "zip" and type != "gz")
                  rulesSatisfied = false
                  errorMsgArr.push("INVALID_FILE_FORMAT: Input file #{input} is not in ZIP or TGZ archive format. Please check the file format.")
                end
              }
            end
          end
        end
        # If we're OK so far, try to grab user's ERCC-related info and see whether the user has any remote storage areas in their database
        if(rulesSatisfied)
          $stderr.debugPuts(__FILE__, __method__, "STATUS", "Checking user's ERCC info.")
          # Check to see what PI the user is associated with
          submitterLogin = wbJobEntity.context['userLogin']
          apiCaller = ApiCaller.new(exRNAInternalKBHost, "/REST/v1/grp/{grp}/kb/{kb}/coll/{coll}/docs?matchProp={matchProp}&matchValues={matchVal}&matchMode=exact&detailed=true", user, pass)
          apiCaller.initInternalRequest(@rackEnv, genbConf.machineNameAlias) if(@rackEnv)
          apiCaller.get({:grp => exRNAInternalKBGroup, :kb => exRNAInternalKBName, :coll => exRNAInternalKBPICodesColl, :matchProp => submitterPropPath, :matchVal => submitterLogin})
          if(!apiCaller.succeeded? and apiCaller.parseRespBody["status"]["statusCode"] != "Forbidden")
            $stderr.debugPuts(__FILE__, __method__, "ERROR", "API caller resp body for failed call to PI KB: #{apiCaller.respBody}")
            errorMsgArr.push("API call failed when trying to grab PI associated with current user. Please try again. If you continue to experience issues, contact Sai (sailakss@bcm.edu).")
            rulesSatisfied = false
          else
            # Set up arrays to store grant numbers and anticipated data repository options
            wbJobEntity.settings['grantNumbers'] = []
            wbJobEntity.settings['anticipatedDataRepos'] = []
            # If we can't find user (or we are unable to search the KB because we're not a member), then he/she is not registered as an ERCC user. We will prompt the user to contact Sai if he/she IS an ERCC user
            if(apiCaller.parseRespBody["data"].size == 0 or apiCaller.parseRespBody["status"]["statusCode"] == "Forbidden")
              wbJobEntity.settings['piName'] = "Non-ERCC PI"
              wbJobEntity.settings['grantNumbers'] << "Non-ERCC Funded Study"
              # Currently, if user is not a member of ERCC, his/her anticipated data repository is "None". This might not make sense, though (what if user is submitting data to dbGaP but isn't ERCC?)
              wbJobEntity.settings['anticipatedDataRepos'] << "None"
            # If user is associated with more than 1 PI, a mistake has occurred and we need to fix it.
            elsif(apiCaller.parseRespBody["data"].size > 1)
              errorMsgArr.push("You are listed as being a submitter under two or more PIs. This is not allowed. Please contact Sai (sailakss@bcm.edu) to fix this issue.")
              rulesSatisfied = false
            else
              # If user is associated with only one PI, then we get that PI's information and save it (PI name, organization, grant numbers and associated grant tags)
              piDoc = BRL::Genboree::KB::KbDoc.new(apiCaller.parseRespBody["data"][0])
              # PI ID 
              piID = piDoc.getPropVal("ERCC PI Code")
              wbJobEntity.settings['piID'] = piID
              # PI Name
              firstName = piDoc.getPropVal("ERCC PI Code.PI First Name")
              middleName = piDoc.getPropVal("ERCC PI Code.PI Middle Name") if(piDoc.getPropVal("ERCC PI Code.PI Middle Name"))
              lastName = piDoc.getPropVal("ERCC PI Code.PI Last Name")
              piName = "#{firstName}"
              piName << " #{middleName}" if(middleName)
              piName << " #{lastName}"
              wbJobEntity.settings['piName'] = piName
              # Grab grant numbers (with associated grant tag)
              grantDetails = piDoc.getPropItems("ERCC PI Code.Grant Details")
              grantDetails.each { |currentGrant|
                currentGrant = BRL::Genboree::KB::KbDoc.new(currentGrant)
                grantNumber = currentGrant.getPropVal("Grant Number")
                grantTag = currentGrant.getPropVal("Grant Number.Grant Tag")
                wbJobEntity.settings['grantNumbers'] << "#{grantNumber} (#{grantTag})"
              }
              # Make sure we add "Non-ERCC Funded Study" to grant numbers list in case ERCC user wants to submit a non-ERCC study  
              wbJobEntity.settings['grantNumbers'] << "Non-ERCC Funded Study"
              # Different options available for anticipated data repository for ERCC users
              wbJobEntity.settings['anticipatedDataRepos'] = ["GEO", "dbGaP", "Both GEO & dbGaP", "None", "Other"]
            end
          end
          $stderr.debugPuts(__FILE__, __method__, "STATUS", "Done checking user's ERCC info.")
          $stderr.debugPuts(__FILE__, __method__, "STATUS", "Checking user's remote storage area info.")
          # Save user's remote storage areas in remoteStorageAreas array
          remoteStorageAreas = []
          output = @dbApiHelper.extractPureUri(outputs[0])
          uri = URI.parse(output)
          host = uri.host
          rcscUri = uri.path
          rcscUri = rcscUri.chomp("?")
          rcscUri << "/files?depth=immediate"
          apiCaller = ApiCaller.new(host, rcscUri, @hostAuthMap)
          apiCaller.initInternalRequest(@rackEnv, genbConf.machineNameAlias) if(@rackEnv)
          apiCaller.get()
          listOfFiles = apiCaller.parseRespBody()["data"]
          listOfFiles.each { |currentFile|
            nameOfFile = currentFile["name"].chomp("/")
            storageType = currentFile["storageType"]
            remoteStorageAreas << nameOfFile if(storageType != "local")
          }
          wbJobEntity.settings['remoteStorageAreas'] = remoteStorageAreas
          $stderr.debugPuts(__FILE__, __method__, "STATUS", "Done checking user's remote storage area info.")
        end
        # If rules are not satisfied, then fill out error message with all the files that were invalid
        unless(rulesSatisfied)
          wbJobEntity.context['wbErrorMsg'] = errorMsgArr
        else
          # Inputs list should contain the updated (and filtered) list of files
          wbJobEntity.inputs = inputsList
        end
      end
      return rulesSatisfied
    end

  end

end ; end; end # module BRL ; module Genboree ; module Tools
