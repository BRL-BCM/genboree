require 'brl/genboree/tools/workbenchRulesHelper'
require 'brl/genboree/tools/workbenchFormHelper'
require 'brl/genboree/rest/helpers/trackApiUriHelper'
require 'brl/genboree/rest/helpers/databaseApiUriHelper'
require 'brl/genboree/abstract/resources/jobFile'
require 'brl/genboree/rest/apiCaller'
include BRL::Genboree::REST

module BRL ; module Genboree ; module Tools
  class ComparativeSignalDataComparisonAtlasRulesHelper < WorkbenchRulesHelper
    TOOL_LABEL = :hidden
    def rulesSatisfied?(wbJobEntity, sectionsToSatisfy=[ :inputs, :outputs, :context, :settings ], toolIdStr=@toolIdStr)
      # Apply basic rules from the rules file (counts, basic types, other simple things)
      rulesSatisfied = super(wbJobEntity, sectionsToSatisfy, toolIdStr)

      if(rulesSatisfied)
        @dbu = BRL::Genboree::DBUtil.new("#{@genbConf.dbrcKey}", nil, nil)
        # Must pass the rest of the checks as well
        rulesSatisfied = false
        outputs = wbJobEntity.outputs
        inputs = wbJobEntity.inputs
        # ------------------------------------------------------------------
        # Check Inputs/Outputs
        # ------------------------------------------------------------------
        # Check 0: If there are 2 inputs, one of them MUST be a folder
        folderPresent = false
        inputs.each { |input|
          if(input !~ BRL::Genboree::REST::Helpers::TrackApiUriHelper::NAME_EXTRACTOR_REGEXP)
            folderPresent = true
          end
        }
        if(!folderPresent and inputs.size == 2)
          wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: In case of 2 inputs, one of them MUST be the output folder from the ROI-Lifter tools"
        else
          # Check 1: does user have write permission to the first db?
          userId = wbJobEntity.context['userId']
          unless(@dbApiHelper.accessibleByUser?(outputs.first, userId, CAN_WRITE_CODES))
            # FAILED: doesn't have write access to output database
            wbJobEntity.context['wbErrorMsg'] =
            {
              :msg => "You don't have permission to write to the first output database.",
              :type => :writeableDbs,
              :info => @dbApiHelper.accessibleDatabasesHash(outputs, userId, CAN_WRITE_CODES)
            }
          else # OK: user can write to the first output database
            # Check 2: If 2 output dbs check if user has permission to write to the second db
            permission = true
            if(outputs.size == 2)
              unless(@dbApiHelper.accessibleByUser?(outputs[1], userId, CAN_WRITE_CODES))
                permission = false
              end
            end
            # Failed: user does not have permission for the second db
            unless(permission)
              # FAILED: doesn't have write access to output database
              wbJobEntity.context['wbErrorMsg'] =
              {
                :msg => "You don't have permission to write to the second output database.",
                :type => :writeableDbs,
                :info => @dbApiHelper.accessibleDatabasesHash(outputs, userId, CAN_WRITE_CODES)
              }
            else
              # Check 3: if inputs.size == 2, i.e, one trk and one input folder, we need to make sure that the folder IS the output
              # from the ROI Lift Over tool
              jobFilePresent = true
              depTrackOrder = nil
              indepTrackOrder = nil
              if(inputs.size == 2)
                folder = nil
                order = 0
                inputs.each { |input|
                  if(input !~ BRL::Genboree::REST::Helpers::TrackApiUriHelper::NAME_EXTRACTOR_REGEXP)
                    folder = input
                    break
                  end
                  order += 1
                }
                if(order == 0)
                  depTrackOrder = 1
                else
                  depTrackOrder = 0
                end
                jobFileUri = "#{folder.chomp("?")}/jobFile.json"
                begin
                  jobFileObj = BRL::Genboree::Abstract::Resources::JobFile.new(jobFileUri, @rackEnv)
                  jobFileObj.parseJobFile()
                  toolName = jobFileObj.context['toolIdStr']
                  jobFilePresent = false if(toolName != 'compEpigenomicsROILifter')
                rescue => err
                  $stderr.puts err
                  jobFilePresent = false
                end
              end
              unless(jobFilePresent) # Failed.
                wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: The input folder MUST be the output folder generated by the 'Comparative Epigenomics - ROI-Lifter' tool."
              else
                # Check 4:  The version of ROI Track must be the same as that of the score track
                correctOrder = true
                errorMsg = ''
                inputsSize = inputs.size
                lifterOutputs = jobFileObj.outputs if(inputsSize == 2)
                if(inputsSize == 3)
                  if(@dbApiHelper.dbVersion(inputs[0]) != @dbApiHelper.dbVersion(inputs[1])) # Failed
                    correctOrder = false
                    errorMsg = 'INVALID_INPUT: The order of input tracks is incorrect. The database version of the first (ROI) track MUST match the version of the second (score) track.'
                  end
                else # 1 track and one folder
                  if(@dbApiHelper.dbVersion(inputs[depTrackOrder]) != @dbApiHelper.dbVersion(lifterOutputs[0]) and @dbApiHelper.dbVersion(inputs[depTrackOrder]) != @dbApiHelper.dbVersion(lifterOutputs[1]))
                    correctOrder = false
                    errorMsg = "INVALID_INPUT: The database versions of the ROI Tracks from the ROI-Lifter job MUST match the score tracks. "
                  end
                end
                unless(correctOrder)
                  wbJobEntity.context['wbErrorMsg'] = errorMsg
                else
                  # Check 5: The two ROI Tracks MUST have different db version
                  sameDbVer = false
                  if(inputsSize == 3)
                    sameDbVer = true if(@dbApiHelper.dbVersion(inputs[0]) == @dbApiHelper.dbVersion(inputs[2]))
                  else
                    sameDbVer = true if(@dbApiHelper.dbVersion(lifterOutputs[0]) == @dbApiHelper.dbVersion(lifterOutputs[1])) # This should not happen since the validation of the ROI-Lifter tool should catch this.
                  end
                  if(sameDbVer)
                    wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: The database versions of the two ROI tracks MUST be different."
                  else
                    # Check 6: The score tracks MUST be high density
                    scoreTrackHighDens = true
                    if(inputsSize == 3)
                      scoreTrackHighDens = false if(!@trkApiHelper.isHdhv?(inputs[1]))
                    else
                      scoreTrackHighDens = false if(!@trkApiHelper.isHdhv?(inputs[depTrackOrder]))
                    end
                    unless(scoreTrackHighDens)
                      wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: The score track MUST be a high density score track. "
                    else
                      # Check 7: The ROI Tracks MUST be non high desnity
                      roiTrackHighDens = false
                      if(inputsSize == 3)
                        roiTrackHighDens = true if(@trkApiHelper.isHdhv?(inputs[0]) or @trkApiHelper.isHdhv?(inputs[2]))
                      else
                        roiTrackHighDens = true if(@trkApiHelper.isHdhv?(lifterOutputs[0]) or @trkApiHelper.isHdhv?(lifterOutputs[1]))
                      end
                      if(roiTrackHighDens)
                        wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: Both of the Regions of Interest (ROI) tracks MUST NOT be high density score tracks. "
                      else
                        outputsSize = outputs.size
                        # Check 8: If there are 2 target dbs, they MUST have different versions
                        if(outputsSize == 2 and (@dbApiHelper.dbVersion(outputs[0]) == @dbApiHelper.dbVersion(outputs[1])))
                          wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: The two target databases MUST have different database versions. "
                        else
                          # Check 9: If there are 2 target dbs, one of them must match one set (ROI & score) of the input tracks and the other must match the other set
                          outputMatch = true
                          if(outputs.size == 2)
                            if(inputsSize == 3)
                              outputMatch = false if((@dbApiHelper.dbVersion(outputs[0]) != @dbApiHelper.dbVersion(inputs[0]) and @dbApiHelper.dbVersion(outputs[0]) != @dbApiHelper.dbVersion(inputs[2])) or
                                                     (@dbApiHelper.dbVersion(outputs[1]) != @dbApiHelper.dbVersion(inputs[0]) and @dbApiHelper.dbVersion(outputs[1]) != @dbApiHelper.dbVersion(inputs[2])))
                            else
                              outputMatch = false if((@dbApiHelper.dbVersion(outputs[0]) != @dbApiHelper.dbVersion(lifterOutputs[0]) and @dbApiHelper.dbVersion(outputs[0]) != @dbApiHelper.dbVersion(lifterOutputs[1])) or
                                                     (@dbApiHelper.dbVersion(outputs[1]) != @dbApiHelper.dbVersion(lifterOutputs[0]) and @dbApiHelper.dbVersion(outputs[1]) != @dbApiHelper.dbVersion(lifterOutputs[1])))
                            end
                          end
                          unless(outputMatch)
                            wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: The database versions of the target databases MUST match the two sets of ROI and score tracks, i.e, one target database MUST match one set of ROI and score track and the other target database MUST match the other set.  "
                          else
                            # Check 10: If there is one target database, the dependent track set must match the version of the target
                            independentMatch = false
                            if(outputsSize == 1)
                              if(inputsSize == 3)
                                independentMatch = true if(@dbApiHelper.dbVersion(outputs[0]) == @dbApiHelper.dbVersion(inputs[1]))
                              else
                                if(@dbApiHelper.dbVersion(outputs[0]) == @dbApiHelper.dbVersion(inputs[depTrackOrder]))
                                  independentMatch = true
                                end
                              end
                            else
                              independentMatch = true
                            end
                            unless(independentMatch)
                              wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: The version of the target database MUST match the version of the 'dependent' ROI Track. "
                            else
                              # If we have 2 inputs we need to overwrite wbJobEntity.inputs. We don't want to do this in the .rhtml for the sake of keeping the 'view' clean.
                              if(inputsSize == 2)
                                trackName = CGI.escape("#{jobFileObj.settings['lffType']}:#{jobFileObj.settings['lffSubType']}")
                                newInputs = []
                                if(@dbApiHelper.dbVersion(lifterOutputs[0]) == @dbApiHelper.dbVersion(inputs[depTrackOrder]))
                                  tempUri = lifterOutputs[0].chomp("?")
                                  newInputs.push("#{tempUri}/trk/#{trackName}?")
                                  newInputs.push(inputs[depTrackOrder])
                                  newInputs.push("#{lifterOutputs[1].chomp("?")}/trk/#{trackName}?")
                                else
                                  tempUri = lifterOutputs[1].chomp("?")
                                  newInputs.push("#{tempUri}/trk/#{trackName}?")
                                  newInputs.push(inputs[depTrackOrder])
                                  newInputs.push("#{lifterOutputs[0].chomp("?")}/trk/#{trackName}")
                                end
                                wbJobEntity.inputs = newInputs
                              end
                              rulesSatisfied = true
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        # ------------------------------------------------------------------
        # CHECK SETTINGS
        # ------------------------------------------------------------------
        if(sectionsToSatisfy.include?(:settings))
          # Check :settings together with info from :outputs :
          unless( sectionsToSatisfy.include?(:outputs) )
            raise ArgumentError, "Cannot validate just :settings without info provided in :outputs."
          end

          rulesSatisfied = false
          # Check 1: check if a folder with the analysis name already exists
          genbConf = BRL::Genboree::GenboreeConfig.load()
          dbrcFile = File.expand_path(ENV['DBRC_FILE'])
          user = @superuserApiDbrc.user
          pass = @superuserApiDbrc.password
          jobFolderPresent = false
          analysisName = wbJobEntity.settings['analysisName']
          parentDir = CGI.escape("Comparative Epigenomics")
          studyName = wbJobEntity.settings['studyName']
          outputs.each { |output|
            if(@dbApiHelper.dbVersion(output) == @dbApiHelper.dbVersion(inputs[0])) # inputs[0] is always 'dependent' at this point
              # Create a folder for this tool named by the analysisName under the Files/ area of thw workbench
              uri = URI.parse(output)
              group = @grpApiHelper.extractName(output)
              db = @dbApiHelper.extractName(output)
              apiCaller = ApiCaller.new(uri.host, "/REST/v1/grp/#{CGI.escape(group)}/db/#{CGI.escape(db)}/file/#{parentDir}/#{studyName}/Signal-Comparison/#{analysisName}/jobFile.json", user, pass)
              apiCaller.initInternalRequest(@rackEnv, genbConf.machineNameAlias) if(@rackEnv)
              apiCaller.get()
              jobFolderPresent = true if(apiCaller.succeeded?)
            end
          }
          if(jobFolderPresent)
            wbJobEntity.context['wbErrorMsg'] = "INVALID_INPUT: A folder with the analysis name: #{analysisName.inspect} already exists. Please choose a different analysis name."
          else
            rulesSatisfied = true
          end
        end
      end

      # Clean up helpers, which cache many things
      @trkApiHelper.clear() if(!@trkApiHelper.nil?)
      @dbApiHelper.clear() if(!@dbApiHelper.nil?)

      return rulesSatisfied
    end

    # It's a good idea to catch any potential errors now instead of relying on the job to do validation because,
    # the job may get queued and the user wouldn't be notified  for an unnecessarily long time that they have something minor wrong with their inputs.
    #
    # [+returns+] boolean
    def warningsExist?(wbJobEntity)
      warningsExist = true

      if(wbJobEntity.context['warningsConfirmed'])
        # The user has confirmed the warnings and wants to proceed
        warningsExist = false
      else # Look for warnings
        @dbu = BRL::Genboree::DBUtil.new("#{@genbConf.dbrcKey}", nil, nil)
        trackExists = false
        # Get track name
        outTrackType = wbJobEntity.settings['lffType'].to_s.strip
        outTrackSubType = wbJobEntity.settings['lffSubType'].to_s.strip
        outTrkName = "#{outTrackType}:#{outTrackSubType}"
        wbJobEntity.outputs.each { |outputDbUri|
          outputDbName = @dbApiHelper.extractName(outputDbUri)
          # Make output track uri
          outTrkUri = "#{@dbApiHelper.extractPureUri(outputDbUri)}/trk/#{CGI.escape(outTrkName)}"
          # CHECK: Does a non-empty output track with the same name already exist in the destination database?
          uploadFile = wbJobEntity.settings['uploadFile'] ? true : false
          if(!@trkApiHelper.empty?(outTrkUri) and uploadFile)
            # WARNING: output track exists and is not empty
            trackExists = true
            break
          end
        }
        if(trackExists)
          wbJobEntity.context['wbErrorMsg'] = "The track: '#{outTrkName}' already exists in the output database(s). The output of this job will be appended to existing data in the track."
        else
          warningsExist = false
        end
      end

      # Clean up helpers, which cache many things
      @trkApiHelper.clear() if(!@trkApiHelper.nil?)
      @dbApiHelper.clear() if(!@dbApiHelper.nil?)

      return warningsExist
    end
  end
end ; end end # module BRL ; module Genboree ; module Tools
