require 'brl/genboree/tools/workbenchRulesHelper'
require 'brl/genboree/tools/workbenchFormHelper'
require 'brl/genboree/graphics/newickTrackListHelper.rb'
require 'brl/genboree/rest/helpers/fileApiUriHelper'
require 'brl/genboree/rest/helpers/databaseApiUriHelper'
require 'uri'
require 'brl/genboree/genboreeUtil'
require 'brl/genboree/dbUtil'
require 'brl/genboree/abstract/resources/user'
require 'brl/genboree/rest/apiCaller'
include BRL::Genboree::REST

module BRL ; module Genboree ; module Tools
  class NewickToTrackListRulesHelper < WorkbenchRulesHelper

    TOOL_ID = 'newickToTrackList'

    def rulesSatisfied?(wbJobEntity, sectionsToSatisfy=[ :inputs, :outputs, :context, :settings ], toolIdStr=@toolIdStr)
      # Apply basic rules from the rules file (counts, basic types, other simple things)
      rulesSatisfied = super(wbJobEntity, sectionsToSatisfy, toolIdStr)
      if(rulesSatisfied)
        # Must pass the rest of the checks as well
        rulesSatisfied = false
        outputs = wbJobEntity.outputs
        inputs = wbJobEntity.inputs
        userId = wbJobEntity.context['userId']
        # Check 1: Version matching
 

        unless(checkDbVersions(inputs + outputs, skipNonDbUris=true)) # Failed
          wbJobEntity.context['wbErrorMsg'] = "The database version of one or more inputs does not match the version of the target database."
        else
          rulesSatisfied = true
          newickFileInput = wbJobEntity.inputs.first
          @fileHelper = BRL::Genboree::REST::Helpers::FileApiUriHelper.new()
        # Check 2: Is input a genboree file?
          if(newickFileInput =~ BRL::Genboree::REST::Helpers::FileApiUriHelper::NAME_EXTRACTOR_REGEXP)
            apiCaller = ApiCaller.new("", "", @hostAuthMap)
            apiCaller.initInternalRequest(@rackEnv, @genbConf.machineNameAlias) if(@rackEnv)
        # Check 3: Is input associated with a trackMap file?
            result = BRL::Genboree::Graphics::NewickTrackListHelper.getTrackMapFile(newickFileInput,apiCaller)
            if(result[:success]) then
              @trackMapFile = result[:uri]
            else
              wbJobEntity.context['wbErrorMsg'] = [ "Your Newick file has no map file associated with it via the TrackMapFile attribute. Cannot map tree leaves to actual tracks!", "The Newick file may not have been generated by a Genboree tool and thus cannot be used as input here.", "Internal API error: #{result[:msg]}"]
              rulesSatisfied = false
            end
          else
            wbJobEntity.context['wbErrorMsg'] = "The supplied input does not appear to be a valid genboree file"
            rulesSatisfied = false
          end
          # Check 4: Is output a genboree db?

          outputDB = outputs.first
          unless (outputDB =~ BRL::Genboree::REST::Helpers::DatabaseApiUriHelper::NAME_EXTRACTOR_REGEXP)
            wbJobEntity.context['wbErrorMsg'] = "The output location does not appear to be a valid genboree database"
            rulesSatisfied = false
          end
          if(rulesSatisfied and sectionsToSatisfy.include?(:settings))
            # Check 5: Have any leaves been selected?
            if(wbJobEntity.settings["selectedLeaves"].nil? or wbJobEntity.settings["selectedLeaves"].empty?)
              wbJobEntity.context['wbErrorMsg'] = "No tree leaves selected. Cannot create track lists."
              rulesSatisfied = false
            end

            if(wbJobEntity.settings["selectListName"].nil? or wbJobEntity.settings["selectListName"].empty? or (wbJobEntity.settings["selectListName"] !~ /\S/))
              wbJobEntity.context['wbErrorMsg'] = "Entity list name for selected tracks cannot be empty."
              rulesSatisfied = false
            end
            if(wbJobEntity.settings["restListName"].nil? or wbJobEntity.settings["restListName"].empty? or (wbJobEntity.settings["restListName"] !~ /\S/))
              wbJobEntity.context['wbErrorMsg'] = "Entity list name for remaining tracks cannot be empty."
              rulesSatisfied = false
            end
            if(rulesSatisfied)
              result = BRL::Genboree::Graphics::NewickTrackListHelper.getNewickTree(newickFileInput,apiCaller,true) #only leaves
              if(result[:success]) then
                @treeLeaves = result[:leaves]
            # Check 6: Have all leaves been selected?
                if(wbJobEntity.settings["selectedLeaves"].length == @treeLeaves.length) then
                  wbJobEntity.context['wbErrorMsg'] = "All tree leaves selected. Cannot create track lists."
                  rulesSatisfied = false
                end

                if(rulesSatisfied)
           # Check 7: Do all selected leaves exist in tree?
                wbJobEntity.settings["selectedLeaves"].each {|leaf|
                  if(!@treeLeaves.member?(leaf)) then
                    wbJobEntity.context['wbErrorMsg'] = "Selected tree leaf #{leaf} does not exist in tree"
                    rulesSatisfied = false
                  end
                  }
                end
              else
                wbJobEntity.context['wbErrorMsg'] = result[:msg]
                rulesSatisfied = false
              end
            end
            if(rulesSatisfied)
              result = BRL::Genboree::Graphics::NewickTrackListHelper.getTrackMapHash(@trackMapFile,apiCaller)
            # Check 8: Do all selected leaves have a mapping in the trackmap file?
              if(result[:success]) then
                nameMap = result[:trackMaps][:nameMap]
                uriMap = result[:trackMaps][:uriMap]
                @treeLeaves.each {|leaf| if(!nameMap.has_key?(leaf)) then
                    wbJobEntity.context['wbErrorMsg'] = "Could not find matching track for #{leaf} in map file #{@fileHelper.extractName(@trackMapFile)}"
                    rulesSatisfied = false
                  end
                  }
              else
                wbJobEntity.context['wbErrorMsg'] = result[:msg]
                rulesSatisfied = false
              end
            end
          end

        end
      end
      return rulesSatisfied
    end
  end
end ; end; end # module BRL ; module Genboree ; module Tools
